# Batman

`Batman` is the coolest.

    Batman = require 'batman'

## Batman.Object

### get
See `Batman.Object.prototype.get`

### set
See `Batman.Object.prototype.set`

## Batman.Object.prototype

`Batman.Object` is the heart of the `Batman` runtime. Instances and subclasses inherit all the `get`/`set` logic, the deep keypath resolution, the `accessor` computation logic, the `Observable` logic, the `event` logic, and more.

    @setup -> @obj = new Batman.Object {foo: 'bar'}

### get(key: String)

`get` retrieves any property from any `Batman.Object`. Instead of doing normal property lookups like you would in normal Javascript, you _must_ use `get` to retrieve anything from a Batman object. `get` also supports lookups on 'deep' keys.

#### get a simple key

    @equal 'bar', -> @obj.get 'foo'

#### get a key on a smart object

    @setup -> @obj.accessor 'baz'
      get: (key) -> true

    @equal true, -> @obj.get 'baz'

Note that while the above works, doing a vanilla JavaScript key access will not!

    @equal undefined, -> @obj['baz']
    @equal undefined, -> @obj.baz

This is because `@obj` has some special keys on it, which can only be accessed through the Batman runtime. Using the runtime is as simple as always using `get` and `set` to retrieve or set properties on `Batman.Object`s. This is a departure from the usual way of doing things, and it takes more code, but it's the only way that the rest of the goodness Batman provides can be implemented.

#### get a deep key

    @setup -> @obj.qux = new Batman.Object({bar: new Batman.Object({baz: 'Bonus!'})})
    @equal 'Bonus!', -> @obj.get 'qux.bar.baz'

#### get a deep key where a middle segment is missing

    @show -> @obj.foo = {}
    @equal undefined, -> @obj.get 'foo.bar.baz'

`get` is smart and will traverse the keypath as deep as it can. If an undefined key is encountered, the `get` will return undefined.

### set(key: String, value: Object)

`set` stores a value in a property on any `Batman.Object`. Instead of doing normal sets like you would in normal Javascript, you _must_ use `set` to retrieve anything from a Batman object.

#### set a simple key

    @equal 'bar', -> @obj.set 'foo', 'bar'
    @equal 'bar', -> @obj.get 'foo'

#### set a key on a smart object

    @setup -> @obj.accessor 'baz'
      get: (key) -> @["_#{key}"]
      set: (key, value) -> @["_#{key}"] = value

    @equal 'qux', -> @obj.set 'baz', 'qux'

Note that while the above works, doing a vanilla JavaScript key access will not!

    @equal undefined, -> @obj['baz']
    @equal undefined, -> @obj.baz
    @equal 'qux', -> @obj.get 'baz'

This is because `@obj` has some special keys on it, which can only be accessed through the Batman runtime. Using the runtime is as simple as always using `get` and `set` to retrieve or set properties on `Batman.Object`s. This is a departure from the usual way of doing things, and it takes more code, but it's the only way that the rest of the goodness Batman provides can be implemented.

### observe(key: String, observer: function(newValue, oldValue))

`observe` adds a change listener to a `Batman.Object`, which then gets called any time the `key` changes. This is the heart of the binding system `Batman` uses in its views because it allows views to be notified when the data they represent changes, and thus update themselves.

    @setup -> @obj = new Batman.Object

#### observe a key for a change

    @setup -> @spy = helpers.createSpy()
    @show -> @obj.observe('foo', @spy)
    @show -> @obj.set('foo', 'bar')
    @deepEqual ['bar', undefined], -> @spy.lastCallArguments

### forget(key: String, function(newValue, oldValue))

`forget` removes a change listener from a `Batman.Object`.

## Batman.Hash.Prototype

### get

### set

## Batman.Set.Prototype

### get

### set
